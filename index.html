<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Group P2P Encrypted Mesh Chat & Image Share</title>
  <style>
    body { max-width:650px; margin:1em auto; font-family:sans-serif; }
    #chat { border:1px solid #bbb; height:340px; overflow:auto; padding:7px; margin-bottom:10px; background:#fafaff;}
    #status { color:green; margin-bottom:6px;}
    #joincodes {font-size:.95em; margin-bottom:1em;}
    .msg { margin-bottom:7px; }
    img { max-width:160px; max-height:120px; display:block; margin-top:3px;}
    .peer { color:#555; font-weight:bold;}
  </style>
</head>
<body>
<h2>Group P2P Encrypted Chat & Image Share</h2>
<div id="status"></div>
<div id="joincodes"></div>

<textarea id="remoteSDP" rows="3" placeholder="Paste others' join codes here, one-per-line..."></textarea><br>
<button id="connect">Connect to Others</button>
<hr>
<div id="chat"></div>
<form id="msgform">
  <input id="msg" autocomplete="off" placeholder="Message..." style="width:60%">
  <button type="submit">Send</button>
  <input type="file" id="file-input" accept="image/png,image/jpeg" />
</form>
<script>
let me = Math.random().toString(36).slice(2,8); // User's local random short id
let peers = {}; // peerid -> {pc, channel, remotePubkey, sharedKey, nickname }
async function genKeyPair(){
  return window.crypto.subtle.generateKey(
    {name:"ECDH",namedCurve:"X25519"}, true, ["deriveKey"]);
}
async function importKey(raw){
  return window.crypto.subtle.importKey("raw", raw, {name:"ECDH",namedCurve:"X25519"}, true, []);
}
async function deriveSharedKey(priv, remoteRaw){
  let remoteKey = await importKey(remoteRaw);
  return window.crypto.subtle.deriveKey(
    {name:"ECDH", public: remoteKey},
    priv, 
    {name:"AES-GCM", length:256}, 
    true, ["encrypt", "decrypt"]);
}
async function exportPub(keyObj){
  return new Uint8Array(await crypto.subtle.exportKey("raw", keyObj));
}
async function encrypt(key, msg){
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(msg);
  const ct = new Uint8Array(await crypto.subtle.encrypt(
    {name:"AES-GCM", iv}, key, enc));
  return btoa([ ...iv, ...ct].map(x=>String.fromCharCode(x)).join(""));
}
async function decrypt(key, dataB64){
  let raw = atob(dataB64);
  let bytes = new Uint8Array([...raw].map(c=>c.charCodeAt(0)));
  let iv = bytes.slice(0,12), ct = bytes.slice(12);
  let pt = await crypto.subtle.decrypt({name:"AES-GCM",iv}, key, ct);
  return new TextDecoder().decode(pt);
}
function bufToB64(buf){return btoa(String.fromCharCode(...buf));}
function b64ToBuf(b64){return new Uint8Array([...atob(b64)].map(c=>c.charCodeAt(0)));
}

let keyPair, myPub;
let currentOfferSDP = "";
let JOIN_CODES = [], WAIT_PEERS = {};

function logStatus(msg){ document.getElementById('status').textContent = msg; }
function appendChat(html){
  let c = document.getElementById('chat');
  c.insertAdjacentHTML('beforeend', html); c.scrollTop = c.scrollHeight;
}

/** Peer create/accept, using mesh */
async function setup(){
  keyPair = await genKeyPair();
  myPub = await exportPub(keyPair.publicKey);

  // Make a join code for this peer
  let pc = new RTCPeerConnection({iceServers:[]});
  let channel = pc.createDataChannel("mesh");
  channel.binaryType = "arraybuffer";
  let ownId = me;

  // Show invite ASAP after createOffer
  pc.createOffer().then(async offer=>{
    await pc.setLocalDescription(offer);

    // Show join code instantly even if not all ICE gathered
    let code = {
      sdp: pc.localDescription.sdp,
      pub: bufToB64(myPub),
      id: ownId
    };
    JOIN_CODES = [btoa(JSON.stringify(code))];
    document.getElementById('joincodes').innerHTML = 
        `<b>Your join code (share instantly):</b>
        <textarea readonly rows=4 style="width:99%">${JOIN_CODES.join('\n')}</textarea>
        <div style="font-size:0.9em;">Can update after connection but <b>usable instantly</b>.</div>`;
  });

  // Update join code as ICE candidates trickle in
  pc.onicecandidate = ()=> {
    if (pc.localDescription) {
      let code = {
        sdp: pc.localDescription.sdp,
        pub: bufToB64(myPub),
        id: ownId
      };
      JOIN_CODES = [btoa(JSON.stringify(code))];
      document.getElementById('joincodes').innerHTML = 
          `<b>Your join code (refreshed):</b>
          <textarea readonly rows=4 style="width:99%">${JOIN_CODES.join('\n')}</textarea>
          <div style="font-size:0.9em;">Will auto-refresh as network details update.</div>`;
    }
  };

  channel.onopen =()=> {
    appendChat(`<div class="msg"><i class="peer">${ownId}</i> [self] connected.</div>`);
    logStatus('You can copy your join code, and paste others to connect.');
    channel.onmessage = (e)=>{};
  };
  peers[ownId] = {
    pc, channel, remotePubkey: keyPair.publicKey, sharedKey: null, nickname: ownId
  };
}
setup();

async function connectJoinCode(codeStr){
  let code;
  try{ code = JSON.parse(atob(codeStr.trim())); }
  catch{ logStatus("Join code invalid."); return; }
  let pid = code.id;
  if(peers[pid]) { logStatus("Already connected to "+pid); return; }
  let remotePub = b64ToBuf(code.pub);
  
  let pc = new RTCPeerConnection({iceServers:[]});
  let channel, sharedKey;
  pc.ondatachannel = (e)=>{
    channel = e.channel;
    channel.binaryType="arraybuffer";
    channel.onopen =()=>{
      appendChat(`<div class="msg"><i class="peer">${pid}</i> connected.</div>`);
      logStatus('Peer '+pid+' now connected.');
    };
    channel.onmessage = async(e)=>{
      if(!sharedKey) return;
      try{
        let obj = JSON.parse(await decrypt(sharedKey, e.data));
        if(obj.text)
          appendChat(`<div class="msg"><span class="peer">${pid}:</span> ${obj.text}</div>`);
        if(obj.image)
          appendChat(`<div class="msg"><span class="peer">${pid} sent image:</span><br><img src="data:image/jpeg;base64,${obj.image}"></div>`);
      }catch(e){ appendChat("<div class=msg style='color:red'>Decryption error from "+pid+"!</div>"); }
    };
  };
  let iceDone=false, localDone=false;
  pc.onicecandidate = ()=>{ if(pc.iceGatheringState==="complete"){ iceDone=true; } };
  await pc.setRemoteDescription({type:"offer", sdp:code.sdp});
  let answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  sharedKey = await deriveSharedKey(keyPair.privateKey, remotePub);
  localDone = true;
  let answerCode = btoa(JSON.stringify({sdp: pc.localDescription.sdp, pub: bufToB64(myPub), id: me}));
  appendChat(`<div class="msg"><b>Send this reply to peer ${pid}:</b>
    <textarea readonly rows=4 style="width:95%">${answerCode}</textarea>
    <span style="font-size:.92em;">They must paste it in their own "Connect to Others" box.</span></div>`);
  WAIT_PEERS[pid] = {pc, sharedKey, id:pid};
  peers[pid] = {pc, sharedKey, channel: null, nickname:pid, remotePubkey:remotePub };
}
async function connectReplyCode(codeStr){
  let code;
  try{ code = JSON.parse(atob(codeStr.trim())); }
  catch{ logStatus("Reply code invalid."); return; }
  let pid = code.id;
  let remotePub = b64ToBuf(code.pub);
  if(peers[pid] && peers[pid].sharedKey) return;
  // This peer must find their created offer RTCPeerConnection and assign remote
  let found = null;
  for(let [k,v] of Object.entries(peers)){
    if(v.pc && v.pc.signalingState==="have-local-offer" && !v.sharedKey){
      found = v;
      break;
    }
  }
  if(!found) { logStatus("Can't find matching pending offer!"); return; }
  await found.pc.setRemoteDescription({type:"answer", sdp:code.sdp});
  found.remotePubkey = remotePub;
  found.sharedKey = await deriveSharedKey(keyPair.privateKey, remotePub);

  if(!found.channel){
    found.channel = found.pc.createDataChannel("mesh");
    found.channel.binaryType="arraybuffer";
    found.channel.onopen = ()=>{
      appendChat(`<div class="msg"><span class="peer">${pid}</span> connected.</div>`);
    };
    found.channel.onmessage = async(e)=>{
      try{
        let obj = JSON.parse(await decrypt(found.sharedKey, e.data));
        if(obj.text)
          appendChat(`<div class="msg"><span class="peer">${pid}:</span> ${obj.text}</div>`);
        if(obj.image)
          appendChat(`<div class="msg"><span class="peer">${pid} sent image:</span><br><img src="data:image/jpeg;base64,${obj.image}"></div>`);
      }catch(e){ appendChat("<div class=msg style='color:red'>Decryption error from "+pid+"!</div>"); }
    };
  }
  logStatus("Joined with "+pid+" successfully.");
}

document.getElementById('connect').onclick = async ()=>{
  let codes = document.getElementById('remoteSDP').value.trim().split(/\n+/);
  for(let code of codes){
    if(!code.trim()) continue;
    try {
      let json = JSON.parse(atob(code));
      if(json.sdp&&json.pub&&json.id) {
        if(!peers[json.id] || !peers[json.id].sharedKey) await connectJoinCode(code);
        else await connectReplyCode(code);
      }
    } catch(e){ logStatus("Could not parse code."); }
  }
};

document.getElementById('msgform').onsubmit = async (e)=>{
  e.preventDefault();
  let msg = document.getElementById('msg').value;
  if(!msg.trim()) return;
  for(let pid in peers){
    let p = peers[pid];
    if(p.channel && p.channel.readyState==="open" && p.sharedKey){
      let payload = JSON.stringify({text:msg});
      p.channel.send(await encrypt(p.sharedKey, payload));
    }
  }
  appendChat(`<div class="msg"><span class="peer">me:</span> ${msg}</div>`);
  document.getElementById('msg').value = "";
};

document.getElementById('file-input').addEventListener('change', async function(){
  let file = this.files[0];
  if(!file) return;
  let fr = new FileReader();
  fr.onload = async function(){
    let arr = new Uint8Array(fr.result);
    let b64 = btoa(String.fromCharCode(...arr));
    for(let pid in peers){
      let p = peers[pid];
      if(p.channel && p.channel.readyState==="open" && p.sharedKey){
        let payload = JSON.stringify({image: b64});
        p.channel.send(await encrypt(p.sharedKey, payload));
      }
    }
    appendChat(`<div class="msg"><span class="peer">me sent image:</span><br><img src="data:image/jpeg;base64,${b64}"></div>`);
  };
  fr.readAsArrayBuffer(file);
});

</script>
<details>
<summary><b>How to use (for groups, no servers!):</b></summary>
<ol>
  <li>Each person opens this site, and their join code appears <b>immediately</b>.</li>
  <li>Each person shares their join code (copy-paste via secure messenger/offline/QR/share).</li>
  <li>Each participant pastes all others' join codes into the "Connect..." textarea—one per line—then clicks Connect. This will generate "reply" codes to share with the owners of the original join codes.</li>
  <li>Send reply codes back to the original owner—they paste those in their box and click Connect.</li>
  <li>Repeat until everyone is listed as "connected."</li>
</ol>
<p style="font-size:0.98em;color:#666;">This forms a full mesh. Each direct link is strongly end-to-end encrypted (X25519+AES-GCM) and traffic never hits a server. Max ~6-8 peers for browser stability.</p>
</details>
</body>
</html>
